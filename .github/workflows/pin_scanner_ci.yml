name: PIN Scanner CI
on:
  workflow_dispatch: # Allows manual triggering from the GitHub UI

jobs:
  run-scanner:
    runs-on: ubuntu-latest
    timeout-minutes: 55 # Max duration for the job to run

    permissions:
      contents: read # Only read permission is required for actions/checkout

    steps:
      - name: 1. Checkout Repository
        uses: actions/checkout@v4

      - name: 2. Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: pip # Caches pip dependencies for faster installation

      - name: 3. Install Dependencies
        run: pip install -r requirements.txt

      - name: 4. Restore/Save Logs Cache
        uses: actions/cache@v4
        id: cache-state # Required for the action to save cache at job end
        with:
          # Only cache log files that accumulate state across runs.
          # `new_find_content.txt` is explicitly cleared by the script at each run,
          # so it should NOT be cached. Caching it would defeat its purpose as a temporary file.
          path: |
            found_pins.log
            potential_pins.log
            new_find_content.txt
          # Use a dynamic key based on OS, branch (ref), and a version identifier for the cache structure.
          # This ensures caches are unique per branch and invalidated if logic changes.
          key: ${{ runner.os }}-pincache-${{ github.ref_name }}-${{ hashFiles('requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pincache-${{ github.ref_name }}- # Fallback for same branch
            ${{ runner.os }}-pincache-                     # Fallback for any branch

      - name: 5. Run the PIN Scanner Script
        env:
          # Pass END_PIN as an environment variable to the script.
          # Consider making START_PIN also configurable via env if needed.
          END_PIN: 99999
        run: python pin_scanner.py

      - name: 6. Check for new content and send Telegram notification
        id: telegram_notification
        if: success() && hashFiles('new_find_content.txt') != ''
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          echo "New content found! Preparing Telegram notification."
          MESSAGE_CONTENT=$(cat new_find_content.txt)
          MESSAGE_LENGTH=$(wc -c < new_find_content.txt)
          TELEGRAM_API="https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}"
          MAX_MSG_LENGTH=4096

          if [ "$MESSAGE_LENGTH" -le "$MAX_MSG_LENGTH" ]; then
            # The message content is wrapped in a MarkdownV2 code block.
            # Note: The '!' in the title is escaped for MarkdownV2 compatibility.
            TEXT_PAYLOAD="ðŸš¨ *New Exam Content Found*\!\n\n\`\`\`\n${MESSAGE_CONTENT}\n\`\`\`"

            # Use jq to safely construct the JSON payload. This prevents injection
            # vulnerabilities if the content contains special JSON characters.
            JSON_PAYLOAD=$(jq -n \
              --arg chat_id "${TELEGRAM_CHAT_ID}" \
              --arg text "$TEXT_PAYLOAD" \
              '{chat_id: $chat_id, text: $text, parse_mode: "MarkdownV2"}')

            curl --fail --location "${TELEGRAM_API}/sendMessage" \
              --header 'Content-Type: application/json' \
              --data-raw "${JSON_PAYLOAD}"
            echo "Telegram notification sent as text."
          else
            # If the message is too long, send it as a document with a caption.
            curl --fail --location "${TELEGRAM_API}/sendDocument" \
              -F chat_id="${TELEGRAM_CHAT_ID}" \
              -F document="@new_find_content.txt" \
              -F caption="ðŸš¨ *New Exam Content Found*\! (content too long for a message)" \
              -F parse_mode="MarkdownV2"
            echo "Telegram notification sent as document."
          fi
